import { Properties } from "csstype";
export type WFUserDefaultType = {
    email: string;
    displayName: string;
};
export type WFUserDefaultRole = "GUEST" | "USER";
export type WFAuthConfig = {};
export class WFAuth<U = WFUserDefaultType, R = WFUserDefaultRole, C = WFAuthConfig> {
    protected user?: U;
    protected role?: R;
    protected config: C;
    constructor(config?: C);
    isLoggedIn(): boolean;
    getRole(): R;
    getUser(): U;
    getConfig(): C;
    logout(): void;
    setUser(user: U): void;
    setRole(role: R): void;
    setConfig(config: C): void;
}
export class WFAuthMiddleware<U, R, C> {
    constructor(auth: WFAuth<U, R, C>);
    allowTo(role: R): boolean;
    disallowedTo(role: R): boolean;
    getAuth(): WFAuth<U, R, C>;
}
export const debug: (...args: any) => void;
export function getElementByXPath(xpath: any, parent: any): Node;
export const getRouteQueryParams: <T extends {}>() => T;
export function getXPathForChangedChild(node: any, parent: any): string;
type navigationArgType = string | {
    to: string;
    type: "replace";
} | {
    type: "reload";
};
export const navigate: (arg: navigationArgType) => void;
export interface ParseOptions {
    /**
     * Set the default delimiter for repeat parameters. (default: `'/'`)
     */
    delimiter?: string;
    /**
     * List of characters to automatically consider prefixes when parsing.
     */
    prefixes?: string;
}
/**
 * Parse a string for the raw tokens.
 */
export function parse(str: string, options?: ParseOptions): Token[];
export interface TokensToFunctionOptions {
    /**
     * When `true` the regexp will be case sensitive. (default: `false`)
     */
    sensitive?: boolean;
    /**
     * Function for encoding input strings for output.
     */
    encode?: (value: string, token: Key) => string;
    /**
     * When `false` the function can produce an invalid (unmatched) path. (default: `true`)
     */
    validate?: boolean;
}
/**
 * Compile a string to a template function for the path.
 */
export function compile<P extends object = object>(str: string, options?: ParseOptions & TokensToFunctionOptions): PathFunction<P>;
export type PathFunction<P extends object = object> = (data?: P) => string;
/**
 * Expose a method for transforming tokens into the path function.
 */
export function tokensToFunction<P extends object = object>(tokens: Token[], options?: TokensToFunctionOptions): PathFunction<P>;
export interface RegexpToFunctionOptions {
    /**
     * Function for decoding strings for params.
     */
    decode?: (value: string, token: Key) => string;
}
/**
 * A match result contains data about the path match.
 */
export interface MatchResult<P extends object = object> {
    path: string;
    index: number;
    params: P;
}
/**
 * A match is either `false` (no match) or a match result.
 */
export type Match<P extends object = object> = false | MatchResult<P>;
/**
 * The match function takes a string and returns whether it matched the path.
 */
export type MatchFunction<P extends object = object> = (path: string) => Match<P>;
/**
 * Create path match function from `path-to-regexp` spec.
 */
export function match<P extends object = object>(str: Path, options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions): MatchFunction<P>;
/**
 * Create a path match function from `path-to-regexp` output.
 */
export function regexpToFunction<P extends object = object>(re: RegExp, keys: Key[], options?: RegexpToFunctionOptions): MatchFunction<P>;
/**
 * Metadata about a key.
 */
export interface Key {
    name: string | number;
    prefix: string;
    suffix: string;
    pattern: string;
    modifier: string;
}
/**
 * A token is a string (nothing special) or key metadata (capture group).
 */
export type Token = string | Key;
export interface TokensToRegexpOptions {
    /**
     * When `true` the regexp will be case sensitive. (default: `false`)
     */
    sensitive?: boolean;
    /**
     * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)
     */
    strict?: boolean;
    /**
     * When `true` the regexp will match to the end of the string. (default: `true`)
     */
    end?: boolean;
    /**
     * When `true` the regexp will match from the beginning of the string. (default: `true`)
     */
    start?: boolean;
    /**
     * Sets the final character for non-ending optimistic matches. (default: `/`)
     */
    delimiter?: string;
    /**
     * List of characters that can also be "end" characters.
     */
    endsWith?: string;
    /**
     * Encode path tokens for use in the `RegExp`.
     */
    encode?: (value: string) => string;
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 */
export function tokensToRegexp(tokens: Token[], keys?: Key[], options?: TokensToRegexpOptions): RegExp;
/**
 * Supported `path-to-regexp` input types.
 */
export type Path = string | RegExp | Array<string | RegExp>;
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 */
export function pathToRegexp(path: Path, keys?: Key[], options?: TokensToRegexpOptions & ParseOptions): RegExp;
export const routeMatch: (routeToMatch: string, route: string, defaultParams?: {
    [key: string]: string | number | boolean;
}, options?: TokensToRegexpOptions & ParseOptions) => any;
export const createComponent: (type: keyof HTMLElementTagNameMap) => WFComponent<HTMLElement>;
export type styleProperties = Properties & {
    [K: `--${string}`]: string;
};
export type queryType<Q = HTMLElement> = string | Element | WFComponent<Q>;
export class WFComponent<EL = HTMLElement> {
    protected element: EL;
    protected cloneEl: EL;
    constructor(query: queryType<EL>);
    protected updateClone(): void;
    getElement(): EL;
    updateTextViaAttrVar(keyPair: {
        [key: string]: string | number;
    }): void;
    updateTextVariable(keyPair: {
        [key: string]: string | number;
    }): void;
    setAttribute(key: string, value: string): void;
    removeAttribute(key: string): void;
    getAttribute(key: string): string;
    hasAttribute(key: string): boolean;
    getChildAsComponents<EL = HTMLElement>(selector: string): WFComponent<EL>[];
    getChildAsComponent<EL = HTMLElement>(selector: string): WFComponent<EL>;
    getManyChildAsComponents<T extends {}>(selectors: {
        [key in keyof T]: string;
    }): { [key_1 in keyof T]: string; } extends infer T_1 ? { [key in keyof T_1]: WFComponent<EL>; } : never;
    getCssClass(): string[];
    addCssClass(className: string): void;
    removeCssClass(className: string): void;
    replaceCssClass(className: string, newClassName: string): void;
    toggleCssClass(className: string): void;
    on<K extends keyof HTMLElementEventMap>(type: K, listener: (this: EL, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    off<K extends keyof ElementEventMap>(type: K, listener: (this: Element, ev: ElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    setText(text: string | number): void;
    getText(): string;
    setTextContent(text: string): void;
    getTextContent(): string;
    setHTML(htmlText: string): void;
    getHTML(): string;
    getCloneAsComponent(): WFComponent<EL>;
    setStyle(style?: styleProperties): void;
    getStyle(): CSSStyleDeclaration;
    appendChild<C = HTMLElement>(child: WFComponent<C>): void;
    remove(): void;
    removeAllChildren(): void;
}
type rowRenderCallbackType<D, R> = (data: {
    rowData: D;
    index: number;
    data: D[];
    rowElement: WFComponent<R>;
}) => WFComponent<R>;
type emptyRenderCallbackType<EM> = (emptyElement: WFComponent<EM>) => WFComponent<EM>;
type loadingRenderCallbackType<L> = (loaderElement: WFComponent<L>) => WFComponent<L>;
export class WFDynamicList<D, EL = HTMLElement, R = HTMLElement, L = HTMLElement, EM = HTMLElement> extends WFComponent<EL> {
    constructor(query: queryType<EL>, config: {
        rowSelector: queryType<R>;
        loaderSelector?: queryType<L>;
        emptySelector?: queryType<EM>;
    });
    rowRenderer(cb: rowRenderCallbackType<D, R>): void;
    emptyRenderer(cb: emptyRenderCallbackType<EM>): void;
    loaderRenderer(cb: loadingRenderCallbackType<L>): void;
    setData(data: D[]): void;
    changeLoadingStatus(state: boolean): void;
    forceRender(): void;
}
export class WFFormComponent<E = {
    [key: string]: File | File[] | string;
}> extends WFComponent<HTMLDivElement> {
    formComponent: WFComponent<HTMLFormElement>;
    defaultFormDisplayStyle: string;
    constructor(query: queryType<HTMLDivElement>);
    getFormData(): E;
    setFromData(data: E): void;
    onFormSubmit(cb: (data: E, ev: SubmitEvent) => void): void;
    submitWebflowForm(): void;
    getFormComponent(): WFComponent<HTMLFormElement>;
    getSuccessComponent(): WFComponent<HTMLDivElement>;
    getErrorComponent(): WFComponent<HTMLDivElement>;
    showSuccessState(): void;
    showErrorState(): void;
    showForm(): void;
    disableForm(): void;
    enableForm(): void;
    getSubmitButton(): WFComponent<HTMLElement>;
    resetForm(): void;
    updateSubmitButtonText(text: string): void;
}
type RouteExecuteFnType = <U, R, C>(data?: {
    [key: string | number]: any;
}, canAccess?: boolean, auth?: WFAuth<U, R, C>) => void;
export class WFRoute<U, R, C> {
    constructor(route: string);
    withMiddleware<UU = U, RR = R, CC = C>(middleware: WFAuthMiddleware<UU, RR, CC>, role: RR, type?: "allow" | "disallow", options?: {
        allowExecutionOnFail?: boolean;
    } | {
        onError?: () => void;
    }): this;
    execute(fn: RouteExecuteFnType): this;
}
/**
 * @description execute code when the page is loaded
 * @param cb callback function
 */
export const onReady: (cb: () => void) => void;
export class WFInvisibleForm<E = {
    [key: string]: string;
}> {
    constructor(formName?: string);
    setFormName(formName: string): void;
    getFormName(): string;
    setFormData(data: E): void;
    getFormData(): E;
    isLoading(): boolean;
    onLoadingChange(fn: (state: boolean) => void): () => void;
    onSuccess(fn: () => void): () => void;
    onError(fn: () => void): () => void;
    submitForm(): void;
}
